<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <canvas></canvas>
        <img />
        <script src="gif.js"></script>
        <script src="gif.worker.js"></script>
        <script type="module">
import webgl from './lib/webgl.js';
import matrix from './lib/matrix.js';
import shapes from './lib/shapes.js';
import colors from './lib/color.js';

let deg2rad = angle => Math.PI * angle / 180;

var vshader = `
attribute vec4 position;
attribute vec4 color;
attribute vec4 normal;
uniform mat4 mvp;
uniform mat4 model;            // model matrix
uniform mat4 inverseTranspose; // inversed transposed model matrix
varying vec4 v_color;
varying vec3 v_normal;
varying vec3 v_position;
varying vec3 v_camDistance;
void main() {

  // Apply the model matrix and the camera matrix to the vertex position
  gl_Position = mvp * position;

  // Set varying position for the fragment shader
  v_position = vec3(model * position);

  // Recompute the face normal
  v_normal = normalize(vec3(inverseTranspose * normal));

  // Set the color
  v_color = color;

  v_camDistance = vec3(mvp * position);
}`;

// Fragment shader program
var fshader = `
precision mediump float;
uniform vec3 lightColor;
uniform vec3 lightPosition;
uniform vec3 ambientLight;
uniform vec4 u_fogColor;
uniform float u_fogNear;
uniform float u_fogFar;
varying vec3 v_normal;
varying vec3 v_position;
varying vec4 v_color;
varying vec3 v_camDistance;
void main() {

  // Compute direction between the light and the current point
  vec3 lightDirection = normalize(lightPosition - v_position);

  // Compute angle between the normal and that direction
  float nDotL = max(dot(lightDirection, v_normal), 0.0);

  // Compute diffuse light proportional to this angle
  vec3 diffuse = lightColor * v_color.rgb * nDotL;

  // Compute ambient light
  vec3 ambient = ambientLight * v_color.rgb;

  // Compute total light (diffuse + ambient)
  vec4 color = vec4(diffuse + ambient, 1.0);

  float fogDistance = length(v_camDistance);
  float fogAmount = smoothstep(u_fogNear, u_fogFar, fogDistance);

  // apply fog
  gl_FragColor = mix(color, u_fogColor, fogAmount);
}`;

            let program;

            let nFrames = 64;
            let width = 507;
            let height = 507;

            let rendered = false;
            let progress = 0; // 0 -> 1
            let bounce = 0; // 0 -> 1 -> 0
            let frameIndex = 0;

            let canvas = document.querySelector('canvas');
            //let ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            let gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });

            let gif = new GIF({
                workers: 2,
                quality: 5
            });
            gif.on('finished', (blob) => {
                var img = document.querySelector('img');
                img.src = URL.createObjectURL(blob);
                rendered = true;
                canvas.style.display = 'none';
            });

            // init

    let color = colors.getRandomColorScheme();
    canvas.style.backgroundColor = color.pale.hsl;

    program = webgl.compile(gl, vshader, fshader);

    // Initialize a cube
    var vertices, normals, indices;
    [vertices, normals, indices] = shapes.cube();

    // Count vertices
    var n = indices.length;

    // Set position, normal buffers
    webgl.buffer(gl, vertices, program, 'position', 3, gl.FLOAT);
    webgl.buffer(gl, normals, program, 'normal', 3, gl.FLOAT);

    // Set indices
    var indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Set cube color
    var materialColor = gl.getAttribLocation(program, 'color');
    gl.vertexAttrib3f(materialColor, color.base.r, color.base.g, color.base.b);

    // Set the clear color and enable the depth test
    gl.clearColor(color.pale.r, color.pale.g, color.pale.b, 1);
    gl.enable(gl.DEPTH_TEST);

    // Set the camera
    var cameraMatrix = matrix.perspective({fov: deg2rad(30), aspect: canvas.width / canvas.height, near: 1, far: 100});
    //cameraMatrix = matrix.transform(cameraMatrix, {y: -16, z: -25});
    cameraMatrix = matrix.lookAt(cameraMatrix, 0, 16, -24, 0, 0, -12);

    // Set the point light color and position
    var lightColor = gl.getUniformLocation(program, 'lightColor');
    gl.uniform3f(lightColor, color.pale.r, color.pale.g, color.pale.b);

    var lightPosition = gl.getUniformLocation(program, 'lightPosition');
    gl.uniform3f(lightPosition, -64, 128, -64);

    // Set the ambient light color
    var ambientLight = gl.getUniformLocation(program, 'ambientLight');
    gl.uniform3f(ambientLight, 0.4, 0.4, 0.4);

    var fogColorLocation = gl.getUniformLocation(program, "u_fogColor");
    var fogNearLocation = gl.getUniformLocation(program, "u_fogNear");
    var fogFarLocation = gl.getUniformLocation(program, "u_fogFar");
    var fogColor = [color.pale.r, color.pale.g, color.pale.b, 1];
    var settings = {
        fogNear: 2,
        fogFar: 24
    };
    gl.uniform4fv(fogColorLocation, fogColor);
    gl.uniform1f(fogNearLocation, settings.fogNear);
    gl.uniform1f(fogFarLocation, settings.fogFar);

    var cuboids = [];
    var nCuboids = 256;
    while(nCuboids > 0) {
        let cuboid = {
            x: -16 + Math.floor(nCuboids / 16) * 2,
            y: -Math.random() * 8,
            z: -24 + (nCuboids % 16) * 2,
            //ry: Math.PI / 4,
            sy: 8
        };
        cuboids.push(cuboid);
        nCuboids -= 1;
    }

            //loop
            let draw = () => {
                // Clear color and depth buffer
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                //gl.clear(gl.COLOR_BUFFER_BIT);
                //gl.clear(gl.DEPTH_BUFFER_BIT);

                cuboids.forEach((cuboid) => {
                    var modelMatrix = matrix.identity();
                    cuboid.z -= 32 / nFrames;
                    if (cuboid.z < -24) {
                        cuboid.z += 32;
                        //cuboid.y = -Math.random() * 8;
                    }
                    modelMatrix = matrix.transform(modelMatrix, cuboid);
                    shapes.drawShape(gl, program, cameraMatrix, modelMatrix, n);
                });

            };

            let onF = () => {
                frameIndex = frameIndex + 1;
                progress = frameIndex / nFrames;
                bounce = 1 - Math.abs(1 - progress * 2);

                draw();

                gif.addFrame(canvas, {
                    copy: true,
                    delay: 40
                });

                if (frameIndex < nFrames) {
                    requestAnimationFrame(onF);
                } else {
                    gif.render();
                }
            };
            onF();

        </script>
    </body>
</html>
