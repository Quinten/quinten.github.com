<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <canvas></canvas>
        <img />
        <script src="gif.js"></script>
        <script src="gif.worker.js"></script>
        <script>
            let nFrames = 50;
            let width = 507;
            let height = 507;

            let rendered = false;
            let progress = 0; // 0 -> 1
            let bounce = 0; // 0 -> 1 -> 0
            let frameIndex = 0;

            let canvas = document.querySelector('canvas');
            let ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;
            canvas.style.background = '#c2b2b4';

            let gif = new GIF({
                workers: 2,
                quality: 5
            });
            gif.on('finished', (blob) => {
                var img = document.querySelector('img');
                img.src = URL.createObjectURL(blob);
                rendered = true;
                canvas.style.display = 'none';
            });

            let angleY = 0;

            let cosY = Math.cos(angleY);
            let sinY = Math.sin(angleY);

            let angleX = -Math.PI * 2 * Math.random();
            //let angleX = 0;
            let cosX = Math.cos(angleX);
            let sinX = Math.sin(angleX);

            let fl = 400;

            let p = [];
            let numPoints = 3600;
            let lineSize = 40;
            var Lx = 0, Ly = 0, Lz = 0;
            function plotOn() {
                let d = Math.round(Math.random()) ? lineSize : -lineSize;
                let r = Math.random() * 3;
                //if (r > 2) Lx = Lx + d;
                //if (r < 1) Ly = Ly + d;
                //if (r < 2 && r > 1) Lz = Lz + d;

                if(r>2)Lx=(Lx+d>fl||Lx+d<-fl)?Lx-d:Lx+d;
                if(r<1)Ly=(Ly+d>fl||Ly+d<-fl)?Ly-d:Ly+d;
                if(r<2&&r>1)Lz=(Lz+d>fl||Lz+d<-fl)?Lz-d:Lz+d;
            };
            for (let i = 0; i < numPoints; i++) {
                p[i] = {};
                plotOn();
                p[i].x =  Lx;
                p[i].y = Ly;
                p[i].z = Lz;
            }
            for (let i = 0; i < numPoints; i++) {

                let x1 = p[i].x * cosY - p[i].z * sinY;
                let z1 = p[i].z * cosY + p[i].x * sinY;

                let y1 = p[i].y * cosX - z1 * sinX;
                let z2 = z1 * cosX + p[i].y * sinX;

                p[i].x = x1;
                p[i].y = y1;
                p[i].z = z2;
            }

            let line = (x1, y1, x2, y2) => {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            angleX = 0;
            angleY = Math.PI * 2 / nFrames;

            cosY = Math.cos(angleY);
            sinY = Math.sin(angleY);
            cosX = Math.cos(angleX);
            sinX = Math.sin(angleX);

            let draw = () => {
                ctx.save();
                ctx.strokeStyle = '#84828F';
                ctx.lineWidth = 2;

                let vpX = width / 2;
                let vpY = height / 2;
                for (let i = 0; i < numPoints; i++) {

                    let x1 = p[i].x * cosY - p[i].z * sinY;
                    let z1 = p[i].z * cosY + p[i].x * sinY;

                    let y1 = p[i].y * cosX - z1 * sinX;
                    let z2 = z1 * cosX + p[i].y * sinX;

                    p[i].x = x1;
                    p[i].y = y1;
                    p[i].z = z2;

                    let scale = fl / (fl + p[i].z);
                    p[i]._x = vpX + p[i].x * scale;
                    p[i]._y = vpY + p[i].y * scale;
                }

                let prevP = p[0];
                for (let i = 1; i < numPoints; i++) {
                    if (
                    //(p[i].z < fl) && (prevP.z < fl) &&
                    (p[i].z > -fl) && (prevP.z > -fl) &&
                    !(((prevP._x < 0) && (p[i]._x > width))
                    || ((prevP._x > width) && (p[i]._x < 0))
                    || ((prevP._y < 0) && (p[i]._y > height))
                    || ((prevP._y > height) && (p[i]._y < 0))))
                    {
                        line(prevP._x, prevP._y, p[i]._x, p[i]._y);
                    }
                    prevP = p[i];
                }
                //prevP = p.shift();
                //plotOn();
                //prevP.x =  Lx;
                //prevP.y = Ly;
                //prevP.z = Lz;
                //p.push(prevP);
            };

            let onF = () => {
                frameIndex = frameIndex + 1;
                progress = frameIndex / nFrames;
                bounce = 1 - Math.abs(1 - progress * 2);

                ctx.save();
                ctx.fillStyle = canvas.style.background;
                ctx.fillRect(0, 0, width, height);
                ctx.restore();

                draw();

                gif.addFrame(canvas, {
                    copy: true,
                    delay: 40
                });

                if (frameIndex < nFrames) {
                    requestAnimationFrame(onF);
                } else {
                    gif.render();
                }
            };
            onF();

        </script>
    </body>
</html>
